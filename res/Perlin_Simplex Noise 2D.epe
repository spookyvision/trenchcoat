{
  "name": "Perlin/Simplex Noise 2D",
  "id": "RtREWXYigJ2RPQNqw",
  "sources": {
    "main": "/*\n  Perlin noise is procedurially generated gradient noise. It's 2D output can be \n  thought of as a random topo map. This pattern is optimized for 2D layouts, not strips.\n  \n  Demo on a 16x16 matrix:\n    https://youtu.be/-dahz1u9DXM\n  Mapper map for four 8x8 matrices:\n    https://gist.github.com/jvyduna/a899c5e6eacddb90257a3e8b55fd1fda\n  8x8 WS2812b matix ($14 ea): \n    https://www.tindie.com/products/electromage/electromage-8x8-led-matrix/\n  \n  perlin2() is based on a square grid.\n  simplex2() is based on a triangular grid.\n  \n  This is a large, complex pattern that's halted on me while developing. If it hangs, \n  play with user controls (e.g. is Stripe Speed 0?) or reload PB and reselect the pattern.\n  \n  The Perlin noise code was adapted from\n    https://github.com/josephg/noisejs/blob/master/perlin.js\n  \n  That code was placed in the public domain by its original author, Stefan Gustavson. \n  You may use it as you see fit, but attribution is appreciated.\n*/\n\n// Setup constants\nvar width = 16 // Width (in pixels) of your matrix\nvar height = pixelCount / width\nvar pixels = array(width) // This will store the height vales of the Perlin noise field\nfor (i = 0; i < width; i++) pixels[i] = array(height) // Allocate 2D array\n\n// User variables\nvar useSimplex = 1, scale = 2, motion = 0, panning = 0, autoColor = 1, colorOffset = 0.4 \nvar stripes = 3, sweepSpeed = 1, subStripes = 1, x0 = 0, y0 = 0, showProgressBar = 0\nvar bassThreshold = 0\nexport function sliderPerlinOrSimplex(v) { useSimplex = v > 0.5 } // Larger = finer grained noise\nexport function sliderScale(v) { scale = 1 + v * 4; needsRecalc = 1 } // Larger = finer grained noise\nexport function sliderMotion(v) { panning = v } // Circular viewport panning speed\nexport function sliderAutoColor(v) { autoColor = v > 0.5 } // Colormode 0 uses specific user-defined colors\nexport function sliderAutoColorPalette(h) { colorOffset = h }\nexport function sliderNumberOfStripes(v) { stripes = 1 + floor(v * 4) } // Number of Stripes that sweep through contours\nexport function sliderStripeSpeed(v) { sweepSpeed = v } // Speed of stripe flow\nexport function sliderStripeWeight(v) { subStripes = 5 - floor(v * 4) } // Number of slots in a stripe - we'll blank out all but 1\nexport function sliderX_Offset(x) { x0 = x * scale * 4; needsRecalc = 1 } // x translation (panning)\nexport function sliderY_Offset(y) { y0 = y * scale * 4; needsRecalc = 1 } // y translation (panning)\nexport function sliderShowProgress(v) { showProgressBar = v > 0.5 } // Display a white progress bar\nexport function sliderBassThreshold(v) { bassThreshold = v * 0.03 } // Enable bass reactive flow. Higher = bass must be louder.\nseed = 30  // Perlin seed - which random heightmap we sweep through\nvar bassDuration = 160  // Duration of the fast-forward upon bass triger (in ms)\n// Only used if autoColor = 0. Colors must be in ascending order. Here's \"fire\".\ncolor1 = 0; color2 = 0.028; color3 = 0.07\n\n// Global state\nneedsRecalc = 1 // When there's translation or scaling, we need to recalc the whole field\nvar bassPlaying, bassTimeAccum, t1SoundOffset // Stuff for sound accelleration\nexport var frequencyData  // Enable sensor expansion board sound spectrum\n\n// Accelerate timer t1 when we've detected bass for bassDuration ms\nfunction reactToSound(delta) {\n  bassTrigger = (frequencyData[2] + frequencyData[3] + \n                 frequencyData[4] + frequencyData[5]) > bassThreshold\n  bassPlaying = bassPlaying || bassTrigger\n  if (bassPlaying) {\n    bassTimeAccum += delta\n    t1SoundOffset += (delta >> 11) * (1 + sweepSpeed)\n    if (t1SoundOffset > 1) t1SoundOffset -= 1\n    if (bassTimeAccum > bassDuration ) {\n      bassTimeAccum = 0\n      bassPlaying = 0\n    }\n  }\n}\n\nexport function beforeRender(delta) {\n  t1 = time(0.44 / sweepSpeed * stripes / 65.536)   // Speed of sweeping countours\n  if (bassThreshold) reactToSound(delta)\n  t1 = (t1 + t1SoundOffset) % 1\n\n  t2 = time(100 / 65.536)                        // Speed of viewport camera panning\n  tx = panning * 40 / scale * sin(PI2 * t2) / 2  // x translation (panning)\n  ty = panning * 40 / scale * cos(PI2 * t2) / 2  // y translation (panning)\n  \n  if (needsRecalc || panning) {\n    recalculate(tx + x0, ty + y0)\n    needsRecalc = 0\n  }\n}\n\nvar minHeight, maxHeight, altRange\nfunction recalculate(offsetX, offsetY) {\n  minHeight = maxHeight = 0\n  for (x = 0; x < width; x++) {\n    for (y = 0; y < height; y++) {\n      noiseFunc = useSimplex ? simplex2 : perlin2\n      pixels[x][y] = noiseFunc(\n          (x / width - offsetX) * scale, \n          (y / height - offsetY) * scale\n        )\n      minHeight = min(minHeight, pixels[x][y])\n      maxHeight = max(maxHeight, pixels[x][y])\n    }\n  }\n  elevationRange = maxHeight - minHeight\n}\n\nexport function render2D(index, x, y) {\n  z = pixels[x * width][y * height] // These perlin noise map values can be in 0..1\n  // n is the normalized height, guaranteed to go from 0..1 for every rendered map\n  n = (z - minHeight) / elevationRange \n  \n  if (autoColor) {\n    // Assign a solid color to each sweeping stripe\n    h = (floor(stripes * (n - t1)) / stripes ) % 1 - colorOffset\n  } else {\n    // Use three specified colors\n    stripes = 3\n    h = color1 + (color2 - color1) * square(n - t1 - 1/3, 2/3) + \n                 (color3 - color2) * square(n - t1 - 2/3, 1/3)\n  }\n  // Colored stripes sweeping along equal height contour lines\n  v = triangle((n - t1) * subStripes * stripes)\n  // Eliminate (subStripe - 1) of the subStripes to make a stripe more separated \n  // from neighbors and thus thinner\n  v *= (floor((1 + n - t1) * subStripes * stripes) % subStripes == 0)\n  \n  hsv(h, 1, v * v)\n\n  // Simple heightmap in blue for testing. Comment out for stripes.\n  // hsv (0.66, 1, n * n) \n  \n  if (showProgressBar) {\n    // Superimpose a white progress bar showing t1 on the last row\n    if (y >= (height - 1) / height && abs(t1 - x) * width < 2) {\n      hsv(0, 0, 1 - clamp(abs((t1 - x) * width), 0, 1))\n    }\n  }\n}\n\n\n\n// Begin code from https://github.com/josephg/noisejs/blob/master/perlin.js\n// 2D Perlin and Simplex Noise - Setup\nvar grad3 = array(12)\nfor (i = 0; i <12; i++) { grad3[i] = array(3) }\n\nvar gradIndex = 0\nfunction grad(x, y, z) {\n  grad3[gradIndex][0] = x\n  grad3[gradIndex][0] = y\n  grad3[gradIndex][0] = z\n  gradIndex++\n}\n\ngrad(1,1,0); grad(-1,1,0); grad(1,-1,0); grad(-1,-1,0)\ngrad(1,0,1); grad(-1,0,1); grad(1,0,-1); grad(-1,0,-1)\ngrad(0,1,1); grad(0,-1,1); grad(0,1,-1); grad(0,-1,-1)\n\nvar p = array(256)\np[0] = 151; p[1] = 160; p[2] = 137; p[3] = 91; p[4] = 90; p[5] = 15; p[6] = 131; p[7] = 13; p[8] = 201; p[9] = 95; p[10] = 96; p[11] = 53; p[12] = 194; p[13] = 233; p[14] = 7; p[15] = 225; p[16] = 140; p[17] = 36; p[18] = 103; p[19] = 30; p[20] = 69; p[21] = 142; p[22] = 8; p[23] = 99; p[24] = 37; p[25] = 240; p[26] = 21; p[27] = 10; p[28] = 23; p[29] = 190; p[30] =  6; p[31] = 148\np[32] = 247; p[33] = 120; p[34] = 234; p[35] = 75; p[36] = 0; p[37] = 26; p[38] = 197; p[39] = 62; p[40] = 94; p[41] = 252; p[42] = 219; p[43] = 203; p[44] = 117; p[45] = 35; p[46] = 11; p[47] = 32; p[48] = 57; p[49] = 177; p[50] = 33; p[51] = 88; p[52] = 237; p[53] = 149; p[54] = 56; p[55] = 87; p[56] = 174; p[57] = 20; p[58] = 125; p[59] = 136; p[60] = 171; p[61] = 168; p[62] =  68; p[63] = 175\np[64] = 74; p[65] = 165; p[66] = 71; p[67] = 134; p[68] = 139; p[69] = 48; p[70] = 27; p[71] = 166; p[72] = 77; p[73] = 146; p[74] = 158; p[75] = 231; p[76] = 83; p[77] = 111; p[78] = 229; p[79] = 122; p[80] = 60; p[81] = 211; p[82] = 133; p[83] = 230; p[84] = 220; p[85] = 105; p[86] = 92; p[87] = 41; p[88] = 55; p[89] = 46; p[90] = 245; p[91] = 40; p[92] = 244; p[93] =  102; p[94] = 143; p[95] = 54\np[96] =  65; p[97] = 25; p[98] = 63; p[99] = 161; p[100] =  1; p[101] = 216; p[102] = 80; p[103] = 73; p[104] = 209; p[105] = 76; p[106] = 132; p[107] = 187; p[108] = 208; p[109] =  89; p[110] = 18; p[111] = 169; p[112] = 200; p[113] = 196; p[114] = 135; p[115] = 130; p[116] = 116; p[117] = 188; p[118] = 159; p[119] = 86; p[120] = 164; p[121] = 100; p[122] = 109; p[123] = 198; p[124] = 173; p[125] = 186; p[126] =  3; p[127] = 64\np[128] = 52; p[129] = 217; p[130] = 226; p[131] = 250; p[132] = 124; p[133] = 123; p[134] = 5; p[135] = 202; p[136] = 38; p[137] = 147; p[138] = 118; p[139] = 126; p[140] = 255; p[141] = 82; p[142] = 85; p[143] = 212; p[144] = 207; p[145] = 206; p[146] = 59; p[147] = 227; p[148] = 47; p[149] = 16; p[150] = 58; p[151] = 17; p[152] = 182; p[153] = 189; p[154] = 28; p[155] = 42; p[156] = 223; p[157] = 183; p[158] = 170; p[159] = 213\np[160] = 119; p[161] = 248; p[162] = 152; p[163] =  2; p[164] = 44; p[165] = 154; p[166] = 163; p[167] =  70; p[168] = 221; p[169] = 153; p[170] = 101; p[171] = 155; p[172] = 167; p[173] =  43; p[174] = 172; p[175] = 9; p[176] = 129; p[177] = 22; p[178] = 39; p[179] = 253; p[180] =  19; p[181] = 98; p[182] = 108; p[183] = 110; p[184] = 79; p[185] = 113; p[186] = 224; p[187] = 232; p[188] = 178; p[189] = 185; p[190] =  112; p[191] = 104\np[192] = 218; p[193] = 246; p[194] = 97; p[195] = 228; p[196] = 251; p[197] = 34; p[198] = 242; p[199] = 193; p[200] = 238; p[201] = 210; p[202] = 144; p[203] = 12; p[204] = 191; p[205] = 179; p[206] = 162; p[207] = 241; p[208] =  81; p[209] = 51; p[210] = 145; p[211] = 235; p[212] = 249; p[213] = 14; p[214] = 239; p[215] = 107; p[216] =  49; p[217] = 192; p[218] = 214; p[219] =  31; p[220] = 181; p[221] = 199; p[222] = 106; p[223] = 157\np[224] = 184; p[225] =  84; p[226] = 204; p[227] = 176; p[228] = 115; p[229] = 121; p[230] = 50; p[231] = 45; p[232] = 127; p[233] =   4; p[234] = 150; p[235] = 254; p[236] = 138; p[237] = 236; p[238] = 205; p[239] = 93; p[240] = 222; p[241] = 114; p[242] = 67; p[243] = 29; p[244] = 24; p[245] = 72; p[246] = 243; p[247] = 141; p[248] = 128; p[249] = 195; p[250] = 78; p[251] = 66; p[252] = 215; p[253] = 61; p[254] = 156; p[255] = 180\n\nvar perm = array(512)\nvar gradP = array(512)\n\n\nfunction perlinSeed(seed) {\n  if (seed > 0 && seed < 1) {\n    // Scale the seed out\n    seed *= 32768\n  }\n\n  seed = floor(seed)\n  if(seed < 256) {\n    seed |= seed << 8\n  }\n  \n  for(i = 0; i < 256; i++) {\n    var perlinv\n    if (i & 1) {\n      perlinv = p[i] ^ (seed & 255)\n    } else {\n      perlinv = p[i] ^ ((seed>>8) & 255)\n    }\n\n    perm[i] = perm[i + 256] = perlinv\n    gradP[i] = gradP[i + 256] = grad3[perlinv % 12]\n  }\n}\nperlinSeed(seed)\n\nfunction dot2(gradElement, x, y) {\n  return gradElement[0] * x + gradElement[1] * y\n}\n\n// Skewing and unskewing factors for 2, 3, and 4 dimensions\nvar F2 = (sqrt(3) - 1) / 2\nvar G2 = (3 - sqrt(3)) / 6\n\n// 2D simplex noise\n// Note: Unlike a typical noise function -1..1, for Pixelblaze this outputs 0 to 1\nfunction simplex2(xin, yin) {\n  var n0, n1, n2 // Noise contributions from the three corners\n  // Skew the input space to determine which simplex cell we're in\n  var s = (xin + yin) * F2 // Hairy factor for 2D\n  var i = floor(xin + s)\n  var j = floor(yin + s)\n  var t = (i + j) * G2\n  var x0 = xin - i + t  // The x,y distances from the cell origin, unskewed.\n  var y0 = yin - j + t\n  // For the 2D case, the simplex shape is an equilateral triangle.\n  // Determine which simplex we are in.\n  var i1, j1  // Offsets for second (middle) corner of simplex in (i,j) coords\n  if(x0>y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n    i1 = 1; j1 = 0\n  } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n    i1 = 0; j1 = 1\n  }\n  // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n  // c = (3-sqrt(3))/6\n  var x1 = x0 - i1 + G2  // Offsets for middle corner in (x,y) unskewed coords\n  var y1 = y0 - j1 + G2\n  var x2 = x0 - 1 + 2 * G2  // Offsets for last corner in (x,y) unskewed coords\n  var y2 = y0 - 1 + 2 * G2\n  // Work out the hashed gradient indices of the three simplex corners\n  i &= 255\n  j &= 255\n  var gi0 = gradP[i+perm[j]];\n  var gi1 = gradP[i+i1+perm[j+j1]];\n  var gi2 = gradP[i+1+perm[j+1]];\n  // Calculate the contribution from the three corners\n  var pst0 = 0.5 - x0 * x0 - y0 * y0\n  if (pst0 < 0) {\n    n0 = 0\n  } else {\n    pst0 *= pst0\n    n0 = pst0 * pst0 * dot2(gi0, x0, y0)  // (x,y) of grad3 used for 2D gradient\n  }\n  var pst1 = 0.5 - x1 * x1 - y1 * y1\n  if (pst1 < 0) {\n    n1 = 0\n  } else {\n    pst1 *= pst1\n    n1 = pst1 * pst1 * dot2(gi1, x1, y1)\n  }\n  var pst2 = 0.5 - x2 * x2 - y2 * y2\n  if (pst2 < 0) {\n    n2 = 0\n  } else {\n    pst2 *= pst2\n    n2 = pst2 * pst2 * dot2(gi2, x2, y2)\n  }\n  // Add contributions from each corner to get the final noise value.\n  // The result is scaled to return values in the interval [0,1].\n  return (70 * (n0 + n1 + n2) + 1) / 2\n}\n\n// Perlin noise functions\nfunction fade(t) {\n  return t * t * t * (t * (t * 6 - 15) + 10)\n}\n\nfunction lerp(a, b, t) {\n  return (1 - t) * a + t * b\n}\n\n// 2D Perlin noise\n// Note: Unlike a typical Perlin function, for Pixelblaze this outputs 0 to 1\nfunction perlin2(x, y) {\n  // Find unit grid cell containing point\n  var X = floor(x)\n  var Y = floor(y)\n  // Get relative xy coordinates of point within that cell\n  x = x - X; y = y - Y\n  // Wrap the integer cells at 255 (smaller integer period can be introduced here)\n  X = X & 255; Y = Y & 255\n\n  // Calculate noise contributions from each of the four corners\n  var n00 = dot2(gradP[X + perm[Y]], x, y)\n  var n01 = dot2(gradP[X + perm[Y + 1]], x, y - 1)\n  var n10 = dot2(gradP[X + 1 + perm[Y]], x - 1, y)\n  var n11 = dot2(gradP[X + 1 + perm[Y + 1]], x - 1, y - 1)\n\n  // Compute the fade curve value for x\n  var u = fade(x)\n\n  // Interpolate the four results\n  return 0.5 + lerp(\n    lerp(n00, n10, u),\n    lerp(n01, n11, u),\n    fade(y)\n  )\n}"
  },
  "preview": "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"
}