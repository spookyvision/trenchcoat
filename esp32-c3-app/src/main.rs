use core::str;
use std::{
    sync::{Arc, Condvar, Mutex},
    thread::{sleep, JoinHandle},
    time::Duration,
};

use trenchcoat::{
    forth::vm::VM,
    pixelblaze::{executor::Executor, ffi::PixelBlazeFFI, traits::PixelBlazeRuntime},
};
mod runtime;
use crate::runtime::{EspRuntime, Led};

pub(crate) mod bsc;
use anyhow::{anyhow, bail};
use embedded_svc::httpd::{registry::Registry, Method, Response};
use esp_idf_svc::{
    httpd, netif::EspNetifStack, nvs::EspDefaultNvs, sysloop::EspSysLoopStack, wifi::EspWifi,
};
// ivmarkov: "binstart gives you a regular Rust STD fn main()"
// If using the `binstart` feature of `esp-idf-sys`, always keep this module imported
use esp_idf_sys::{self, c_types, esp, EspError};
use log::{info, warn};

#[toml_cfg::toml_config]
pub struct Config {
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
}

const PIXEL_COUNT: usize = 1;

fn main() -> anyhow::Result<()> {
    esp_idf_sys::link_patches();
    esp_idf_svc::log::EspLogger::initialize_default();

    info!("trenchcoat!");
    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;

    let _wifi = bsc::wifi::wifi(app_config.wifi_ssid, app_config.wifi_psk)?;

    let mutex = Arc::new((Mutex::new(None), Condvar::new()));
    let (_httpd, _vm_thread) = httpd(mutex.clone())?;

    let _why_though = mutex.0.lock().unwrap();
    loop {
        sleep(Duration::from_millis(10));
    }

    Ok(())
}

#[allow(unused)]
struct Wifi {
    esp_wifi: EspWifi,
    netif_stack: Arc<EspNetifStack>,
    sys_loop_stack: Arc<EspSysLoopStack>,
    default_nvs: Arc<EspDefaultNvs>,
}

fn httpd(
    _mutex: Arc<(Mutex<Option<u32>>, Condvar)>,
) -> anyhow::Result<(httpd::Server, JoinHandle<()>)> {
    // let mut bytecode = vec![0; 512];
    // bytecode[0..VM_BYTES.len()].copy_from_slice(VM_BYTES.as_slice());

    // let mut vm = postcard::from_bytes_cobs::<VM<PixelBlazeFFI, EspRuntime>>(&mut bytecode).unwrap();

    let mut vm = VM::new_empty(EspRuntime::default());
    vm.runtime_mut().init(PIXEL_COUNT);
    let mut executor = Executor::new(vm, PIXEL_COUNT);
    executor.start();
    let executor = Arc::new(Mutex::new(executor));

    let frame_ex = executor.clone();
    let vm_thread_handle = std::thread::spawn(move || loop {
        sleep(Duration::from_millis(1000));
    });
    let vm_thread_handle = std::thread::spawn(move || loop {
        if let Ok(mut executor) = frame_ex.lock() {
            executor.do_frame();
        }
        sleep(Duration::from_millis(50));
    });

    let server = httpd::ServerRegistry::new()
        .at("/")
        .post(move |mut request| {
            info!("got new stuff!");
            if let Ok(mut ser_vm) = request.as_bytes() {
                if let Ok(mut ex_handle) = executor.lock() {
                    let mut next_vm =
                        postcard::from_bytes_cobs::<VM<PixelBlazeFFI, EspRuntime>>(&mut ser_vm)?;
                    let runtime = ex_handle.take_vm().unwrap().dismember();
                    *next_vm.runtime_mut() = runtime;
                    ex_handle.set_vm(next_vm);
                    info!("restarting vm!");
                    ex_handle.start();
                }
            }
            let response = Response::ok();
            response
                .header("Access-Control-Allow-Origin", "*")
                .header("Content-type", "text/plain")
                .into()
        })?
        .at("/")
        .handler(Method::Options, |_request| {
            let response = Response::ok();
            response
                .header("Access-Control-Allow-Origin", "*")
                .header("Content-type", "text/plain")
                .into()
        })?;

    #[cfg(esp32s2)]
    let server = httpd_ulp_endpoints(server, mutex)?;

    let server = server.start(&Default::default());

    server.map(|server| (server, vm_thread_handle))
}
