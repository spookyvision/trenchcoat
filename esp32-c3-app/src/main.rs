use core::str;
use std::{
    sync::{Arc, Condvar, Mutex},
    thread::{sleep, JoinHandle},
    time::Duration,
};

use trenchcoat::{
    forth::vm::VM,
    pixelblaze::{executor::Executor, ffi::PixelBlazeFFI, traits::PixelBlazeRuntime},
};
mod runtime;
use crate::runtime::{EspRuntime, Led};

mod bsc;
use anyhow::{anyhow, bail};
use embedded_svc::{
    httpd::{registry::Registry, Response},
    wifi::{
        self, AuthMethod, ClientConfiguration, ClientConnectionStatus, ClientIpStatus,
        ClientStatus, Wifi as _,
    },
};
use esp_idf_svc::{
    httpd, netif::EspNetifStack, nvs::EspDefaultNvs, sysloop::EspSysLoopStack, wifi::EspWifi,
};
// ivmarkov: "binstart gives you a regular Rust STD fn main()"
// If using the `binstart` feature of `esp-idf-sys`, always keep this module imported
use esp_idf_sys::{self, c_types, esp, EspError};
use log::info;
#[toml_cfg::toml_config]
pub struct Config {
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
}

static VM_BYTES: &[u8; 239] = include_bytes!("../../res/rainbow melt.tcb");

fn main() -> anyhow::Result<()> {
    esp_idf_sys::link_patches();

    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;

    let _wifi = bsc::wifi::wifi(app_config.wifi_ssid, app_config.wifi_psk)?;

    let mutex = Arc::new((Mutex::new(None), Condvar::new()));
    let (_httpd, _vm_thread) = httpd(mutex.clone())?;

    // loop {
    //     println!("main…");
    //     sleep(Duration::from_millis(1000));
    // }

    let _wait = mutex.0.lock().unwrap();
    println!("kbye");
    loop {
        println!("main…");
        sleep(Duration::from_millis(1000));
    }

    Ok(())
}

#[allow(unused)]
struct Wifi {
    esp_wifi: EspWifi,
    netif_stack: Arc<EspNetifStack>,
    sys_loop_stack: Arc<EspSysLoopStack>,
    default_nvs: Arc<EspDefaultNvs>,
}

fn httpd(
    mutex: Arc<(Mutex<Option<u32>>, Condvar)>,
) -> anyhow::Result<(httpd::Server, JoinHandle<()>)> {
    // let _vm_thread = std::thread::spawn(vm);
    let mut bytecode = vec![0; 512];
    bytecode[0..VM_BYTES.len()].copy_from_slice(VM_BYTES.as_slice());
    let mut vm = postcard::from_bytes_cobs::<VM<PixelBlazeFFI, EspRuntime>>(&mut bytecode).unwrap();

    let pixel_count = 1;
    vm.runtime_mut().init(pixel_count);
    let mut executor = Executor::new(vm, pixel_count);
    executor.start();
    let executor = Arc::new(Mutex::new(executor));

    let frame_ex = executor.clone();
    let vm_thread_handle = std::thread::spawn(move || loop {
        let handle = frame_ex.lock();
        match handle {
            Ok(mut executor) => {
                executor.do_frame();
            }
            Err(e) => println!("mutex bork! {e:?}"),
        }
        sleep(Duration::from_millis(100));
    });

    let server = httpd::ServerRegistry::new()
        .at("/")
        .get(|_| Ok("Hello from Rust!".into()))?
        .at("/foo")
        .get(|_| bail!("Boo, something happened!"))?
        .at("/bar")
        .get(|_| {
            Response::new(403)
                .status_message("No permissions")
                .body("You have no permissions to access this page".into())
                .into()
        })?
        .at("/panic")
        .get(|_| panic!("User requested a panic!"))?;

    #[cfg(esp32s2)]
    let server = httpd_ulp_endpoints(server, mutex)?;

    let server = server.start(&Default::default());

    server.map(|server| (server, vm_thread_handle))
}
